declarative knowledge vs imperative knowledge, declarative refering to statements of fact and imperative refering to procedures of solving problems given statements of fact about the problems

int, float, string, set, tuple, list, dictionary, boolean, class, object, method, function, function invocation, combined type such as list of dictionaries, lists of lambdas or lists of sublists, expression such as any operator applied to unary or ternary operands

+ - * / // % ** ( ) != == 

and, or, not

> >= < <=

& | ^ ~ << >>

. * **

[ ] [start:stop + 1] [start:stop + 1:step] [i][j][k] 

: , =

Addition, Subtraction, Multiplication, True Division, Floor Division, Remainder or Modulus, Exponentiation, Parentheses

Inequality, Equality

Logical AND, Logical OR, Logical NOT

Greater-than, Greater-than or Equal-to, Less-than, Less-than or Equal-to

Bitwise AND, OR, XOR, NOT

Dot operator, Unpacking operator, Packing operator

Subscript operator, Subscript operator with splice, Subscript operator with double splice, Arbitrary length subscripts for nested subscriptable types

Comma operator, colon operator, assignment operator

True, False, lambda, yield, from x import y as z

assert, global, nonlocal, pass, del

break, continue, is, is not, else, as

try:

except Error: (e.g. IOError, ValueError)

finally:

else:

Error as e, e.method

def function(arguments):
	body
	return

abstraction, decomposition

def main(args):
	body

if __name__ == "__main__": main()

for x in range(start, stop + 1, step):

for x in iterable: (e.g. list, tuple, set, dictionary, string)

for x in a:
	for y in a:

for x in a:
	for y in b:

while (Boolean):
	while (Boolean):

def recursion(arg_1, arg_2):
	base case x:
		body
	body
	recursive call / recursion (recursion(arg_1 - 1, arg_2 - 1))
	return

iteration, recursion, base cases, condition checks, mathematical definition

if (boolean):
	if (boolean):
		if (boolean):

		elif (boolean):
		elif (boolean):
		else:
	elif (boolean):
	elif (boolean):
	else:
elif (boolean):
elif (boolean:
else:

match (object):

	case a:
		body
	case b:
		body
	case c:
		body
	case d:
		body

branching, control flow

def function(*args):
	body

def function (**kwargs):
	body

A = 1993
B = 1955
C = 1955.1993
D = "Charles Truscott and Mark Watters"

A = {9, 0, 2, 1, 0}
B = ["Charles", "47", 47, 3.14, 2.718, lambda q: q ** 2 / 3.14]
C = (A, B), 
D = {"Apples": "$2", "Pears": "$3", "Peaches": "$4", "Bananas": "$10"}

p = True
q = False
r = False
s = True

a = p and q
b = r or s
c = (p and q) or (r or s)
d = not ((p and q) or (r or s))

class Fraction(object):
	def __init__(self, numerator, denominator):
		self.numerator = numerator
		self.denominator = denominator

	def __str__
	def __repr__
	def __add__
	def __subtract__
	def __lt__
	def __gt__

A = Fraction(3.14, 2)

x = [lambda x, y: x + y, lambda x, y: x / y, lambda x, y: x ** y]

type(x[0])

def function(a, b)
	body
	...
	return

B = function(47, Charles)

C = [[2, 4, 8, 1], [9, 0, 2, 1, 0], [13, 1, 1993], [10, 4, 1955], [10, 4, 1990]]

=> 2 + 2
=> 2 - 2
=> (2 + 2) ** (2 - 2)
	1

=> (True and False) or (True and True)

Algorithmic Complexity, Approximation, Searching and Sorting, Python Standard Library, Program definition and requirements analysis and software testing and systems theory, Object Oriented Programming such as setters, getters, data and method attributes, magic methods, polymorphism and inheritance

